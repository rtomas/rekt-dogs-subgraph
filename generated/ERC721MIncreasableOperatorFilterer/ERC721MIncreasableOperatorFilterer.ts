// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get approved(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this);
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll;

  constructor(event: ApprovalForAll) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class ConsecutiveTransfer extends ethereum.Event {
  get params(): ConsecutiveTransfer__Params {
    return new ConsecutiveTransfer__Params(this);
  }
}

export class ConsecutiveTransfer__Params {
  _event: ConsecutiveTransfer;

  constructor(event: ConsecutiveTransfer) {
    this._event = event;
  }

  get fromTokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get toTokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get from(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class DisableIncreaseMaxMintableSupply extends ethereum.Event {
  get params(): DisableIncreaseMaxMintableSupply__Params {
    return new DisableIncreaseMaxMintableSupply__Params(this);
  }
}

export class DisableIncreaseMaxMintableSupply__Params {
  _event: DisableIncreaseMaxMintableSupply;

  constructor(event: DisableIncreaseMaxMintableSupply) {
    this._event = event;
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PermanentBaseURI extends ethereum.Event {
  get params(): PermanentBaseURI__Params {
    return new PermanentBaseURI__Params(this);
  }
}

export class PermanentBaseURI__Params {
  _event: PermanentBaseURI;

  constructor(event: PermanentBaseURI) {
    this._event = event;
  }

  get baseURI(): string {
    return this._event.parameters[0].value.toString();
  }
}

export class SetActiveStage extends ethereum.Event {
  get params(): SetActiveStage__Params {
    return new SetActiveStage__Params(this);
  }
}

export class SetActiveStage__Params {
  _event: SetActiveStage;

  constructor(event: SetActiveStage) {
    this._event = event;
  }

  get activeStage(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class SetBaseURI extends ethereum.Event {
  get params(): SetBaseURI__Params {
    return new SetBaseURI__Params(this);
  }
}

export class SetBaseURI__Params {
  _event: SetBaseURI;

  constructor(event: SetBaseURI) {
    this._event = event;
  }

  get baseURI(): string {
    return this._event.parameters[0].value.toString();
  }
}

export class SetCosigner extends ethereum.Event {
  get params(): SetCosigner__Params {
    return new SetCosigner__Params(this);
  }
}

export class SetCosigner__Params {
  _event: SetCosigner;

  constructor(event: SetCosigner) {
    this._event = event;
  }

  get cosigner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class SetCrossmintAddress extends ethereum.Event {
  get params(): SetCrossmintAddress__Params {
    return new SetCrossmintAddress__Params(this);
  }
}

export class SetCrossmintAddress__Params {
  _event: SetCrossmintAddress;

  constructor(event: SetCrossmintAddress) {
    this._event = event;
  }

  get crossmintAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class SetGlobalWalletLimit extends ethereum.Event {
  get params(): SetGlobalWalletLimit__Params {
    return new SetGlobalWalletLimit__Params(this);
  }
}

export class SetGlobalWalletLimit__Params {
  _event: SetGlobalWalletLimit;

  constructor(event: SetGlobalWalletLimit) {
    this._event = event;
  }

  get globalWalletLimit(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class SetMaxMintableSupply extends ethereum.Event {
  get params(): SetMaxMintableSupply__Params {
    return new SetMaxMintableSupply__Params(this);
  }
}

export class SetMaxMintableSupply__Params {
  _event: SetMaxMintableSupply;

  constructor(event: SetMaxMintableSupply) {
    this._event = event;
  }

  get maxMintableSupply(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class SetMintable extends ethereum.Event {
  get params(): SetMintable__Params {
    return new SetMintable__Params(this);
  }
}

export class SetMintable__Params {
  _event: SetMintable;

  constructor(event: SetMintable) {
    this._event = event;
  }

  get mintable(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }
}

export class SetTimestampExpirySeconds extends ethereum.Event {
  get params(): SetTimestampExpirySeconds__Params {
    return new SetTimestampExpirySeconds__Params(this);
  }
}

export class SetTimestampExpirySeconds__Params {
  _event: SetTimestampExpirySeconds;

  constructor(event: SetTimestampExpirySeconds) {
    this._event = event;
  }

  get expiry(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class UpdateStage extends ethereum.Event {
  get params(): UpdateStage__Params {
    return new UpdateStage__Params(this);
  }
}

export class UpdateStage__Params {
  _event: UpdateStage;

  constructor(event: UpdateStage) {
    this._event = event;
  }

  get stage(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get price(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get walletLimit(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get merkleRoot(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get maxStageSupply(): i32 {
    return this._event.parameters[4].value.toI32();
  }

  get startTimeUnixSeconds(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get endTimeUnixSeconds(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get value(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class ERC721MIncreasableOperatorFilterer__explicitOwnershipOfResultValue0Struct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get startTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get burned(): boolean {
    return this[2].toBoolean();
  }

  get extraData(): i32 {
    return this[3].toI32();
  }
}

export class ERC721MIncreasableOperatorFilterer__explicitOwnershipsOfResultValue0Struct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get startTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get burned(): boolean {
    return this[2].toBoolean();
  }

  get extraData(): i32 {
    return this[3].toI32();
  }
}

export class ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct extends ethereum.Tuple {
  get price(): BigInt {
    return this[0].toBigInt();
  }

  get walletLimit(): BigInt {
    return this[1].toBigInt();
  }

  get merkleRoot(): Bytes {
    return this[2].toBytes();
  }

  get maxStageSupply(): i32 {
    return this[3].toI32();
  }

  get startTimeUnixSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get endTimeUnixSeconds(): BigInt {
    return this[5].toBigInt();
  }
}

export class ERC721MIncreasableOperatorFilterer__getStageInfoResult {
  value0: ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct;
  value1: BigInt;
  value2: BigInt;

  constructor(
    value0: ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct,
    value1: BigInt,
    value2: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTuple(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getValue0(): ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }

  getValue2(): BigInt {
    return this.value2;
  }
}

export class ERC721MIncreasableOperatorFilterer extends ethereum.SmartContract {
  static bind(address: Address): ERC721MIncreasableOperatorFilterer {
    return new ERC721MIncreasableOperatorFilterer(
      "ERC721MIncreasableOperatorFilterer",
      address
    );
  }

  balanceOf(owner: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  explicitOwnershipOf(
    tokenId: BigInt
  ): ERC721MIncreasableOperatorFilterer__explicitOwnershipOfResultValue0Struct {
    let result = super.call(
      "explicitOwnershipOf",
      "explicitOwnershipOf(uint256):((address,uint64,bool,uint24))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );

    return changetype<
      ERC721MIncreasableOperatorFilterer__explicitOwnershipOfResultValue0Struct
    >(result[0].toTuple());
  }

  try_explicitOwnershipOf(
    tokenId: BigInt
  ): ethereum.CallResult<
    ERC721MIncreasableOperatorFilterer__explicitOwnershipOfResultValue0Struct
  > {
    let result = super.tryCall(
      "explicitOwnershipOf",
      "explicitOwnershipOf(uint256):((address,uint64,bool,uint24))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<
        ERC721MIncreasableOperatorFilterer__explicitOwnershipOfResultValue0Struct
      >(value[0].toTuple())
    );
  }

  explicitOwnershipsOf(
    tokenIds: Array<BigInt>
  ): Array<
    ERC721MIncreasableOperatorFilterer__explicitOwnershipsOfResultValue0Struct
  > {
    let result = super.call(
      "explicitOwnershipsOf",
      "explicitOwnershipsOf(uint256[]):((address,uint64,bool,uint24)[])",
      [ethereum.Value.fromUnsignedBigIntArray(tokenIds)]
    );

    return result[0].toTupleArray<
      ERC721MIncreasableOperatorFilterer__explicitOwnershipsOfResultValue0Struct
    >();
  }

  try_explicitOwnershipsOf(
    tokenIds: Array<BigInt>
  ): ethereum.CallResult<
    Array<
      ERC721MIncreasableOperatorFilterer__explicitOwnershipsOfResultValue0Struct
    >
  > {
    let result = super.tryCall(
      "explicitOwnershipsOf",
      "explicitOwnershipsOf(uint256[]):((address,uint64,bool,uint24)[])",
      [ethereum.Value.fromUnsignedBigIntArray(tokenIds)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        ERC721MIncreasableOperatorFilterer__explicitOwnershipsOfResultValue0Struct
      >()
    );
  }

  getActiveStageFromTimestamp(timestamp: BigInt): BigInt {
    let result = super.call(
      "getActiveStageFromTimestamp",
      "getActiveStageFromTimestamp(uint64):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );

    return result[0].toBigInt();
  }

  try_getActiveStageFromTimestamp(
    timestamp: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getActiveStageFromTimestamp",
      "getActiveStageFromTimestamp(uint64):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getApproved(tokenId: BigInt): Address {
    let result = super.call("getApproved", "getApproved(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);

    return result[0].toAddress();
  }

  try_getApproved(tokenId: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getApproved",
      "getApproved(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCanIncreaseMaxMintableSupply(): boolean {
    let result = super.call(
      "getCanIncreaseMaxMintableSupply",
      "getCanIncreaseMaxMintableSupply():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_getCanIncreaseMaxMintableSupply(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "getCanIncreaseMaxMintableSupply",
      "getCanIncreaseMaxMintableSupply():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getCosignDigest(minter: Address, qty: BigInt, timestamp: BigInt): Bytes {
    let result = super.call(
      "getCosignDigest",
      "getCosignDigest(address,uint32,uint64):(bytes32)",
      [
        ethereum.Value.fromAddress(minter),
        ethereum.Value.fromUnsignedBigInt(qty),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );

    return result[0].toBytes();
  }

  try_getCosignDigest(
    minter: Address,
    qty: BigInt,
    timestamp: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getCosignDigest",
      "getCosignDigest(address,uint32,uint64):(bytes32)",
      [
        ethereum.Value.fromAddress(minter),
        ethereum.Value.fromUnsignedBigInt(qty),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getCosignNonce(minter: Address): BigInt {
    let result = super.call(
      "getCosignNonce",
      "getCosignNonce(address):(uint256)",
      [ethereum.Value.fromAddress(minter)]
    );

    return result[0].toBigInt();
  }

  try_getCosignNonce(minter: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getCosignNonce",
      "getCosignNonce(address):(uint256)",
      [ethereum.Value.fromAddress(minter)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getCosigner(): Address {
    let result = super.call("getCosigner", "getCosigner():(address)", []);

    return result[0].toAddress();
  }

  try_getCosigner(): ethereum.CallResult<Address> {
    let result = super.tryCall("getCosigner", "getCosigner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCrossmintAddress(): Address {
    let result = super.call(
      "getCrossmintAddress",
      "getCrossmintAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getCrossmintAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getCrossmintAddress",
      "getCrossmintAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getGlobalWalletLimit(): BigInt {
    let result = super.call(
      "getGlobalWalletLimit",
      "getGlobalWalletLimit():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getGlobalWalletLimit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getGlobalWalletLimit",
      "getGlobalWalletLimit():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMaxMintableSupply(): BigInt {
    let result = super.call(
      "getMaxMintableSupply",
      "getMaxMintableSupply():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getMaxMintableSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMaxMintableSupply",
      "getMaxMintableSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMintable(): boolean {
    let result = super.call("getMintable", "getMintable():(bool)", []);

    return result[0].toBoolean();
  }

  try_getMintable(): ethereum.CallResult<boolean> {
    let result = super.tryCall("getMintable", "getMintable():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getNumberStages(): BigInt {
    let result = super.call(
      "getNumberStages",
      "getNumberStages():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getNumberStages(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNumberStages",
      "getNumberStages():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getStageInfo(
    index: BigInt
  ): ERC721MIncreasableOperatorFilterer__getStageInfoResult {
    let result = super.call(
      "getStageInfo",
      "getStageInfo(uint256):((uint80,uint32,bytes32,uint24,uint64,uint64),uint32,uint256)",
      [ethereum.Value.fromUnsignedBigInt(index)]
    );

    return changetype<ERC721MIncreasableOperatorFilterer__getStageInfoResult>(
      new ERC721MIncreasableOperatorFilterer__getStageInfoResult(
        changetype<
          ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct
        >(result[0].toTuple()),
        result[1].toBigInt(),
        result[2].toBigInt()
      )
    );
  }

  try_getStageInfo(
    index: BigInt
  ): ethereum.CallResult<
    ERC721MIncreasableOperatorFilterer__getStageInfoResult
  > {
    let result = super.tryCall(
      "getStageInfo",
      "getStageInfo(uint256):((uint80,uint32,bytes32,uint24,uint64,uint64),uint32,uint256)",
      [ethereum.Value.fromUnsignedBigInt(index)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<ERC721MIncreasableOperatorFilterer__getStageInfoResult>(
        new ERC721MIncreasableOperatorFilterer__getStageInfoResult(
          changetype<
            ERC721MIncreasableOperatorFilterer__getStageInfoResultValue0Struct
          >(value[0].toTuple()),
          value[1].toBigInt(),
          value[2].toBigInt()
        )
      )
    );
  }

  getTimestampExpirySeconds(): BigInt {
    let result = super.call(
      "getTimestampExpirySeconds",
      "getTimestampExpirySeconds():(uint64)",
      []
    );

    return result[0].toBigInt();
  }

  try_getTimestampExpirySeconds(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTimestampExpirySeconds",
      "getTimestampExpirySeconds():(uint64)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenURISuffix(): string {
    let result = super.call(
      "getTokenURISuffix",
      "getTokenURISuffix():(string)",
      []
    );

    return result[0].toString();
  }

  try_getTokenURISuffix(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "getTokenURISuffix",
      "getTokenURISuffix():(string)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  isApprovedForAll(owner: Address, operator: Address): boolean {
    let result = super.call(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(operator)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedForAll(
    owner: Address,
    operator: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  ownerOf(tokenId: BigInt): Address {
    let result = super.call("ownerOf", "ownerOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);

    return result[0].toAddress();
  }

  try_ownerOf(tokenId: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("ownerOf", "ownerOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  tokenURI(tokenId: BigInt): string {
    let result = super.call("tokenURI", "tokenURI(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);

    return result[0].toString();
  }

  try_tokenURI(tokenId: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("tokenURI", "tokenURI(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  tokensOfOwner(owner: Address): Array<BigInt> {
    let result = super.call(
      "tokensOfOwner",
      "tokensOfOwner(address):(uint256[])",
      [ethereum.Value.fromAddress(owner)]
    );

    return result[0].toBigIntArray();
  }

  try_tokensOfOwner(owner: Address): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "tokensOfOwner",
      "tokensOfOwner(address):(uint256[])",
      [ethereum.Value.fromAddress(owner)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  tokensOfOwnerIn(owner: Address, start: BigInt, stop: BigInt): Array<BigInt> {
    let result = super.call(
      "tokensOfOwnerIn",
      "tokensOfOwnerIn(address,uint256,uint256):(uint256[])",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(stop)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_tokensOfOwnerIn(
    owner: Address,
    start: BigInt,
    stop: BigInt
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "tokensOfOwnerIn",
      "tokensOfOwnerIn(address,uint256,uint256):(uint256[])",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(stop)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  totalMintedByAddress(a: Address): BigInt {
    let result = super.call(
      "totalMintedByAddress",
      "totalMintedByAddress(address):(uint256)",
      [ethereum.Value.fromAddress(a)]
    );

    return result[0].toBigInt();
  }

  try_totalMintedByAddress(a: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalMintedByAddress",
      "totalMintedByAddress(address):(uint256)",
      [ethereum.Value.fromAddress(a)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get collectionName(): string {
    return this._call.inputValues[0].value.toString();
  }

  get collectionSymbol(): string {
    return this._call.inputValues[1].value.toString();
  }

  get tokenURISuffix(): string {
    return this._call.inputValues[2].value.toString();
  }

  get maxMintableSupply(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get globalWalletLimit(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get cosigner(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get timestampExpirySeconds(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class CrossmintCall extends ethereum.Call {
  get inputs(): CrossmintCall__Inputs {
    return new CrossmintCall__Inputs(this);
  }

  get outputs(): CrossmintCall__Outputs {
    return new CrossmintCall__Outputs(this);
  }
}

export class CrossmintCall__Inputs {
  _call: CrossmintCall;

  constructor(call: CrossmintCall) {
    this._call = call;
  }

  get qty(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get proof(): Array<Bytes> {
    return this._call.inputValues[2].value.toBytesArray();
  }

  get timestamp(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get signature(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class CrossmintCall__Outputs {
  _call: CrossmintCall;

  constructor(call: CrossmintCall) {
    this._call = call;
  }
}

export class DisableIncreaseMaxMintableSupplyCall extends ethereum.Call {
  get inputs(): DisableIncreaseMaxMintableSupplyCall__Inputs {
    return new DisableIncreaseMaxMintableSupplyCall__Inputs(this);
  }

  get outputs(): DisableIncreaseMaxMintableSupplyCall__Outputs {
    return new DisableIncreaseMaxMintableSupplyCall__Outputs(this);
  }
}

export class DisableIncreaseMaxMintableSupplyCall__Inputs {
  _call: DisableIncreaseMaxMintableSupplyCall;

  constructor(call: DisableIncreaseMaxMintableSupplyCall) {
    this._call = call;
  }
}

export class DisableIncreaseMaxMintableSupplyCall__Outputs {
  _call: DisableIncreaseMaxMintableSupplyCall;

  constructor(call: DisableIncreaseMaxMintableSupplyCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get qty(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get proof(): Array<Bytes> {
    return this._call.inputValues[1].value.toBytesArray();
  }

  get timestamp(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get signature(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class OwnerMintCall extends ethereum.Call {
  get inputs(): OwnerMintCall__Inputs {
    return new OwnerMintCall__Inputs(this);
  }

  get outputs(): OwnerMintCall__Outputs {
    return new OwnerMintCall__Outputs(this);
  }
}

export class OwnerMintCall__Inputs {
  _call: OwnerMintCall;

  constructor(call: OwnerMintCall) {
    this._call = call;
  }

  get qty(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class OwnerMintCall__Outputs {
  _call: OwnerMintCall;

  constructor(call: OwnerMintCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SafeTransferFromCall extends ethereum.Call {
  get inputs(): SafeTransferFromCall__Inputs {
    return new SafeTransferFromCall__Inputs(this);
  }

  get outputs(): SafeTransferFromCall__Outputs {
    return new SafeTransferFromCall__Outputs(this);
  }
}

export class SafeTransferFromCall__Inputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SafeTransferFromCall__Outputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }
}

export class SafeTransferFrom1Call extends ethereum.Call {
  get inputs(): SafeTransferFrom1Call__Inputs {
    return new SafeTransferFrom1Call__Inputs(this);
  }

  get outputs(): SafeTransferFrom1Call__Outputs {
    return new SafeTransferFrom1Call__Outputs(this);
  }
}

export class SafeTransferFrom1Call__Inputs {
  _call: SafeTransferFrom1Call;

  constructor(call: SafeTransferFrom1Call) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class SafeTransferFrom1Call__Outputs {
  _call: SafeTransferFrom1Call;

  constructor(call: SafeTransferFrom1Call) {
    this._call = call;
  }
}

export class SetApprovalForAllCall extends ethereum.Call {
  get inputs(): SetApprovalForAllCall__Inputs {
    return new SetApprovalForAllCall__Inputs(this);
  }

  get outputs(): SetApprovalForAllCall__Outputs {
    return new SetApprovalForAllCall__Outputs(this);
  }
}

export class SetApprovalForAllCall__Inputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetApprovalForAllCall__Outputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }
}

export class SetBaseURICall extends ethereum.Call {
  get inputs(): SetBaseURICall__Inputs {
    return new SetBaseURICall__Inputs(this);
  }

  get outputs(): SetBaseURICall__Outputs {
    return new SetBaseURICall__Outputs(this);
  }
}

export class SetBaseURICall__Inputs {
  _call: SetBaseURICall;

  constructor(call: SetBaseURICall) {
    this._call = call;
  }

  get baseURI(): string {
    return this._call.inputValues[0].value.toString();
  }
}

export class SetBaseURICall__Outputs {
  _call: SetBaseURICall;

  constructor(call: SetBaseURICall) {
    this._call = call;
  }
}

export class SetBaseURIPermanentCall extends ethereum.Call {
  get inputs(): SetBaseURIPermanentCall__Inputs {
    return new SetBaseURIPermanentCall__Inputs(this);
  }

  get outputs(): SetBaseURIPermanentCall__Outputs {
    return new SetBaseURIPermanentCall__Outputs(this);
  }
}

export class SetBaseURIPermanentCall__Inputs {
  _call: SetBaseURIPermanentCall;

  constructor(call: SetBaseURIPermanentCall) {
    this._call = call;
  }
}

export class SetBaseURIPermanentCall__Outputs {
  _call: SetBaseURIPermanentCall;

  constructor(call: SetBaseURIPermanentCall) {
    this._call = call;
  }
}

export class SetCosignerCall extends ethereum.Call {
  get inputs(): SetCosignerCall__Inputs {
    return new SetCosignerCall__Inputs(this);
  }

  get outputs(): SetCosignerCall__Outputs {
    return new SetCosignerCall__Outputs(this);
  }
}

export class SetCosignerCall__Inputs {
  _call: SetCosignerCall;

  constructor(call: SetCosignerCall) {
    this._call = call;
  }

  get cosigner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetCosignerCall__Outputs {
  _call: SetCosignerCall;

  constructor(call: SetCosignerCall) {
    this._call = call;
  }
}

export class SetCrossmintAddressCall extends ethereum.Call {
  get inputs(): SetCrossmintAddressCall__Inputs {
    return new SetCrossmintAddressCall__Inputs(this);
  }

  get outputs(): SetCrossmintAddressCall__Outputs {
    return new SetCrossmintAddressCall__Outputs(this);
  }
}

export class SetCrossmintAddressCall__Inputs {
  _call: SetCrossmintAddressCall;

  constructor(call: SetCrossmintAddressCall) {
    this._call = call;
  }

  get crossmintAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetCrossmintAddressCall__Outputs {
  _call: SetCrossmintAddressCall;

  constructor(call: SetCrossmintAddressCall) {
    this._call = call;
  }
}

export class SetGlobalWalletLimitCall extends ethereum.Call {
  get inputs(): SetGlobalWalletLimitCall__Inputs {
    return new SetGlobalWalletLimitCall__Inputs(this);
  }

  get outputs(): SetGlobalWalletLimitCall__Outputs {
    return new SetGlobalWalletLimitCall__Outputs(this);
  }
}

export class SetGlobalWalletLimitCall__Inputs {
  _call: SetGlobalWalletLimitCall;

  constructor(call: SetGlobalWalletLimitCall) {
    this._call = call;
  }

  get globalWalletLimit(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetGlobalWalletLimitCall__Outputs {
  _call: SetGlobalWalletLimitCall;

  constructor(call: SetGlobalWalletLimitCall) {
    this._call = call;
  }
}

export class SetMaxMintableSupplyCall extends ethereum.Call {
  get inputs(): SetMaxMintableSupplyCall__Inputs {
    return new SetMaxMintableSupplyCall__Inputs(this);
  }

  get outputs(): SetMaxMintableSupplyCall__Outputs {
    return new SetMaxMintableSupplyCall__Outputs(this);
  }
}

export class SetMaxMintableSupplyCall__Inputs {
  _call: SetMaxMintableSupplyCall;

  constructor(call: SetMaxMintableSupplyCall) {
    this._call = call;
  }

  get maxMintableSupply(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMaxMintableSupplyCall__Outputs {
  _call: SetMaxMintableSupplyCall;

  constructor(call: SetMaxMintableSupplyCall) {
    this._call = call;
  }
}

export class SetMintableCall extends ethereum.Call {
  get inputs(): SetMintableCall__Inputs {
    return new SetMintableCall__Inputs(this);
  }

  get outputs(): SetMintableCall__Outputs {
    return new SetMintableCall__Outputs(this);
  }
}

export class SetMintableCall__Inputs {
  _call: SetMintableCall;

  constructor(call: SetMintableCall) {
    this._call = call;
  }

  get mintable(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetMintableCall__Outputs {
  _call: SetMintableCall;

  constructor(call: SetMintableCall) {
    this._call = call;
  }
}

export class SetStagesCall extends ethereum.Call {
  get inputs(): SetStagesCall__Inputs {
    return new SetStagesCall__Inputs(this);
  }

  get outputs(): SetStagesCall__Outputs {
    return new SetStagesCall__Outputs(this);
  }
}

export class SetStagesCall__Inputs {
  _call: SetStagesCall;

  constructor(call: SetStagesCall) {
    this._call = call;
  }

  get newStages(): Array<SetStagesCallNewStagesStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SetStagesCallNewStagesStruct
    >();
  }
}

export class SetStagesCall__Outputs {
  _call: SetStagesCall;

  constructor(call: SetStagesCall) {
    this._call = call;
  }
}

export class SetStagesCallNewStagesStruct extends ethereum.Tuple {
  get price(): BigInt {
    return this[0].toBigInt();
  }

  get walletLimit(): BigInt {
    return this[1].toBigInt();
  }

  get merkleRoot(): Bytes {
    return this[2].toBytes();
  }

  get maxStageSupply(): i32 {
    return this[3].toI32();
  }

  get startTimeUnixSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get endTimeUnixSeconds(): BigInt {
    return this[5].toBigInt();
  }
}

export class SetTimestampExpirySecondsCall extends ethereum.Call {
  get inputs(): SetTimestampExpirySecondsCall__Inputs {
    return new SetTimestampExpirySecondsCall__Inputs(this);
  }

  get outputs(): SetTimestampExpirySecondsCall__Outputs {
    return new SetTimestampExpirySecondsCall__Outputs(this);
  }
}

export class SetTimestampExpirySecondsCall__Inputs {
  _call: SetTimestampExpirySecondsCall;

  constructor(call: SetTimestampExpirySecondsCall) {
    this._call = call;
  }

  get expiry(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetTimestampExpirySecondsCall__Outputs {
  _call: SetTimestampExpirySecondsCall;

  constructor(call: SetTimestampExpirySecondsCall) {
    this._call = call;
  }
}

export class SetTokenURISuffixCall extends ethereum.Call {
  get inputs(): SetTokenURISuffixCall__Inputs {
    return new SetTokenURISuffixCall__Inputs(this);
  }

  get outputs(): SetTokenURISuffixCall__Outputs {
    return new SetTokenURISuffixCall__Outputs(this);
  }
}

export class SetTokenURISuffixCall__Inputs {
  _call: SetTokenURISuffixCall;

  constructor(call: SetTokenURISuffixCall) {
    this._call = call;
  }

  get suffix(): string {
    return this._call.inputValues[0].value.toString();
  }
}

export class SetTokenURISuffixCall__Outputs {
  _call: SetTokenURISuffixCall;

  constructor(call: SetTokenURISuffixCall) {
    this._call = call;
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UpdateStageCall extends ethereum.Call {
  get inputs(): UpdateStageCall__Inputs {
    return new UpdateStageCall__Inputs(this);
  }

  get outputs(): UpdateStageCall__Outputs {
    return new UpdateStageCall__Outputs(this);
  }
}

export class UpdateStageCall__Inputs {
  _call: UpdateStageCall;

  constructor(call: UpdateStageCall) {
    this._call = call;
  }

  get index(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get price(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get walletLimit(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get merkleRoot(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get maxStageSupply(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get startTimeUnixSeconds(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get endTimeUnixSeconds(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }
}

export class UpdateStageCall__Outputs {
  _call: UpdateStageCall;

  constructor(call: UpdateStageCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}
